# Gold 1

## 문제
어떤 N개의 수가 주어져 있다. 그런데 중간에 수의 변경이 빈번히 일어나고 그 중간에 어떤 부분의 합을 구하려 한다. 만약에 1,2,3,4,5 라는 수가 있고, 3번째 수를 6으로 바꾸고 2번째부터 5번째까지 합을 구하라고 한다면 17을 출력하면 되는 것이다. 그리고 그 상태에서 다섯 번째 수를 2로 바꾸고 3번째부터 5번째까지 합을 구하라고 한다면 12가 될 것이다.

## 입력
첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)과 M(1 ≤ M ≤ 10,000), K(1 ≤ K ≤ 10,000) 가 주어진다. M은 수의 변경이 일어나는 횟수이고, K는 구간의 합을 구하는 횟수이다. 그리고 둘째 줄부터 N+1번째 줄까지 N개의 수가 주어진다. 그리고 N+2번째 줄부터 N+M+K+1번째 줄까지 세 개의 정수 a, b, c가 주어지는데, a가 1인 경우 b(1 ≤ b ≤ N)번째 수를 c로 바꾸고 a가 2인 경우에는 b(1 ≤ b ≤ N)번째 수부터 c(b ≤ c ≤ N)번째 수까지의 합을 구하여 출력하면 된다.

입력으로 주어지는 모든 수는 -263보다 크거나 같고, 263-1보다 작거나 같은 정수이다.

## 출력
첫째 줄부터 K줄에 걸쳐 구한 구간의 합을 출력한다. 단, 정답은 -263보다 크거나 같고, 263-1보다 작거나 같은 정수이다.

## Thinking!!
N, M, K // N개의 수, M개의 수의 변경, K개의 출력

M+K번 a, b, c가 입력됨.
a가 1이면 b 를 c로, a가 2면 b부터 C까지의 수의 합을 구하면 된다.

단순 누적 합으로는 이 문제를 풀 수 없으니(갱신 및 구간 변경이 잦음)
세그먼트 트리랑 펜윅 트리(Fenwick Tree, BIT) 둘 중 하나를 사용하면 된다

tree[i]와 수들의 배열 a[i]에 대해서,
숫자 i를 2진수로 변환했을 때, 마지막으로 나온 1의 크기가 i의 담당 크기.
ex) 6 -> 110, 2^1 = 2이기 때문에, tree[6] = a[5] + a[6]

1. 배열 준비

- arr[1..N] : 원본 값 저장
- tree[1..N] : 펜윅 트리용 배열 (0은 안 씀)

2. 초기화

입력받은 arr[i] 로, update(i, arr[i]) 한 번씩 돌리거나
아니면 처음부터 update 로만 채우기

3. 필수 함수 두 개

- prefix_sum(x)
- - res = 0
- - while x > 0:
- - - res += tree[x]
- - - x -= (x & -x)
- - return res
- update(i, diff)
- - while i <= N:
- - - tree[i] += diff
- - - i += (i & -i)

4. 쿼리 처리

- 타입 1: “b번째를 c로 바꾸기”
- - diff = c - arr[b]
- - arr[b] = c
- - update(b, diff)
- 타입 2: “b~c 구간합”
- - ans = prefix_sum(c) - prefix_sum(b-1)