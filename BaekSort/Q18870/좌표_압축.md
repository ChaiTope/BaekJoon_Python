# Silver 2

## 문제
수직선 위에 N개의 좌표 X1, X2, ..., XN이 있다. 이 좌표에 좌표 압축을 적용하려고 한다.

Xi를 좌표 압축한 결과 X'i의 값은 Xi > Xj를 만족하는 서로 다른 좌표 Xj의 개수와 같아야 한다.

X1, X2, ..., XN에 좌표 압축을 적용한 결과 X'1, X'2, ..., X'N를 출력해보자.

## 입력
첫째 줄에 N이 주어진다.

둘째 줄에는 공백 한 칸으로 구분된 X1, X2, ..., XN이 주어진다.

## 출력
첫째 줄에 X'1, X'2, ..., X'N을 공백 한 칸으로 구분해서 출력한다.

## Thinking!!!
그니까... 전체 좌표중에서 해당 좌표보다 작은 좌표의 갯수를 출력하라는 거잖아.
2 4 -10 4 -9가 입력값이면, 2 3 0 3 1
즉, 2보다 작은 값 2개 4보다 작은 값 3개 이런 식으로 출력하라는 뜻.

한번 풀어보자.
1. 일단 배열에 싹 다 넣어버리고
2. 다른 배열에 이 해당 값보다 작은 갯수를 넣어서
3. 출력한다.
4. 시간초과다!

## 1차 시도

    import sys

    N = int(input())
    inp = list(map(int, sys.stdin.readline().strip().split()))
    
    out = sorted(inp)
    count = 0
    res = [[] for _ in range(N)]
    for i in range(N-1):
        if out[i] != out[i+1]:
            res[i] = count
            count += 1
        else:
            res[i] = count
    if out[N-1] == out[N-2]:
        res[N-1] = count
    else:
        res[N-1] = count+1
    
    sol = []
    
    for i in range(N):
        for j in range(N):
            if inp[i] == out[j]:
                sol.append(res[j])
                break
    
    sys.stdout.write(" ".join(map(str, sol)))

1. 값을 일단 받아서 리스트로 저장.
2. 저장한 리스트를 정렬한 값을 새로운 배열에 저장
3. 정렬한 값들을 거슬러 올라가면서 이전값과 달라졌으면(증가했으면) 카운트 증가시킴
4. 정렬 한 값의 배열에서 인접한 두 수를 비교하며 두 수가 같으면 count를 그대로ㅓ
5. 다르면 count를 증가시키며 결과(res)배열에 저장
6. (out)정렬한 값에 따른 (res)결과값이 저장됨.
7. (sol)배열에 inp[i]와 out[j]값이 같으면 res[j]값을 대입
8. 이 과정으로 정렬한 순서를 다시 원상복구함.

근데 이 원상복구하는 과정에서 2중 반복문을 사용하기 때문에 값이 커지면 시간초과가 일어남
이 과정을 다른 방식으로 수정해야 함.

이 로직을 간소화 하기 위해 공부하는 중에 새로운 함수를 학습함,
enumerate()를 사용하면 리스트를 튜플리스트(0부터 N까지, 원래 리스트값) 형태로 만들 수 잇음
그리고 이 튜플 리스트를 {a, b for b, a in enumerate()}를 사용하면 해쉬 테이블 형태로 저장이 가능함.
이 해쉬 테이블은 값을 입력하면 그 값에 대한 결과가 출력,
예를 들어, 

compression_map = {

-10: 0,

-9: 1,

2: 2,

4: 3

}

이런 형식의 해쉬 테이블이라면, -10을 넣으면 0이 튀어나옴.

결국 [compression_map[num] for num in inp] 형식으로
위의 과정들(딕셔너리 변환이라고 통칭)을 거친 해쉬테이블에 처음 입력값 배열의 값을 순서대로 넣으면
압축된 좌표만 얻을 수 있음.