# Platinum 5

## 문제
박성원은 이 문제를 풀지 못했다.

서로 다른 정수로 이루어진 집합이 있다. 이 집합의 순열을 합치면 큰 정수 하나를 만들 수 있다. 예를 들어, {5221,40,1,58,9}로 5221401589를 만들 수 있다. 합친수가 정수 K로 나누어 떨어지는 순열을 구하는 프로그램을 작성하시오.

하지만, 박성원은 이 문제를 풀지 못했다.

따라서 박성원은 그냥 랜덤하게 순열 하나를 정답이라고 출력하려고 한다. 이 문제에는 정답이 여러 개 있을 수도 있고, 박성원이 우연히 문제의 정답을 맞출 수도 있다.

박성원이 우연히 정답을 맞출 확률을 분수로 출력하는 프로그램을 작성하시오.

## 입력
첫째 줄에 집합의 수의 개수 N이 주어진다. N은 15보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 집합에 포함된 수가 주어진다. 각 수의 길이는 길어야 50인 자연수이다. 마지막 줄에는 K가 주어진다. K는 100보다 작거나 같은 자연수이다.

## 출력
첫째 줄에 정답을 기약분수 형태로 출력한다. p/q꼴로 출력하며, p는 분자, q는 분모이다. 정답이 0인 경우는 0/1로, 1인 경우는 1/1로 출력한다.

## Thinking!!
일단 풀이는 비트마스크 + DP라고는 하는데, 논리가 맞는지만 먼저 보자

    import itertools
    import math
    import sys
    
    input = sys.stdin.readline
    
    N = int(input())
    arr = [input().rstrip() for _ in range(N)]
    K = int(input())
    p, q = 0, 0
    nPr = itertools.permutations(arr, N)
    
    for l in nPr:
        num = int("".join(l))
        q += 1
        if num % K == 0:
            p += 1
    
    gcd = math.gcd(p, q)
    print(str(p//gcd) + "/" + str(q//gcd))

일단 예제정도의 범위정도는 풀리는 코드.


논리 흐름을 한 줄로 정리하면

1. 각 문자열을 K로 나눈 나머지(mod) 계산 
2. 10^len % K 미리 계산 
3. 비트마스크 DP로 모든 “순열 상태”를 카운팅 
4. 최종 mask에서 나머지가 0인 경우의 수가 정답의 분자 
5. 전체 순열 수 N! 가 분모 
6. p/q 를 기약분수로 출력