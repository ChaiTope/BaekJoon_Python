# Silver 3

## 문제  
오늘도 서준이는 병합 정렬 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.  

N개의 서로 다른 양의 정수가 저장된 배열 A가 있다. 병합 정렬로 배열 A를 오름차순 정렬할 경우 배열 A에 K번째 저장되는 수를 구해서 우리 서준이를 도와주자.  

크기가 N인 배열에 대한 병합 정렬 의사 코드는 다음과 같다.

    merge_sort(A[p..r]) { # A[p..r]을 오름차순 정렬한다.
        if (p < r) then {
            q <- ⌊(p + r) / 2⌋;       # q는 p, r의 중간 지점
            merge_sort(A, p, q);      # 전반부 정렬
            merge_sort(A, q + 1, r);  # 후반부 정렬
            merge(A, p, q, r);        # 병합
        }
    }
    
    # A[p..q]와 A[q+1..r]을 병합하여 A[p..r]을 오름차순 정렬된 상태로 만든다.
    # A[p..q]와 A[q+1..r]은 이미 오름차순으로 정렬되어 있다.
    merge(A[], p, q, r) {
        i <- p; j <- q + 1; t <- 1;
        while (i ≤ q and j ≤ r) {
            if (A[i] ≤ A[j])
            then tmp[t++] <- A[i++]; # tmp[t] <- A[i]; t++; i++;
            else tmp[t++] <- A[j++]; # tmp[t] <- A[j]; t++; j++;
        }
        while (i ≤ q)  # 왼쪽 배열 부분이 남은 경우
            tmp[t++] <- A[i++];
        while (j ≤ r)  # 오른쪽 배열 부분이 남은 경우
            tmp[t++] <- A[j++];
        i <- p; t <- 1;
        while (i ≤ r)  # 결과를 A[p..r]에 저장
            A[i++] <- tmp[t++]; 
    }

## 입력  
첫째 줄에 배열 A의 크기 N (5 ≤ N ≤ 500,000), 저장 횟수 K (1 ≤ K ≤ 100,000,000)가 주어진다.  
다음 줄에 서로 다른 배열 A의 원소 A1, A2, ..., AN이 주어진다. (1 ≤ Ai ≤ 1,000,000,000)

## 출력  
배열 A에 K번째 저장되는 수를 출력한다.  
저장 횟수가 K보다 작으면 -1을 출력한다.

## Thinking!!
노트에 써보면서 이해했다. 4 5 1 3 2 이게 4 5/ 1/ 3 2 4 / 5 / 1 / 3 / 2 로 전부 분해되고,
4 5/ 1/ 3/ 2 이렇게 다시 붙으면서 4 5 가 저장. 그리고 이게 반영되어서 4 5 1 3 2
그 후에 1 4 5 / 3/ 2 이렇게 붙으면서 1 5 1 3 2 / 1 4 1 3 2 / 1 4 5 3 2 이렇게 변환되는거지
그 후에 3 2 가 붙으면서 1 4 5 2 2 / 1 4 5 2 3 이렇게 변하고, 1 4 5/ 2 3 이 붙으면서
1 2 5 2 3 / 1 2 3 2 3 / 1 2 3 4 3 / 1 2 3 4 5 이렇게 변환이 끝나는거고.

병합 정렬 자체를 처음 보고, 저장하는 방식이 독특해서 이해하는데 꽤 오랜 시간이 걸림.
