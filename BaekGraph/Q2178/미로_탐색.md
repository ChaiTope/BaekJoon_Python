# Silver 1

## 문제
N×M크기의 배열로 표현되는 미로가 있다.

    1	0	1	1	1	1
    1	0	1	0	1	0
    1	0	1	0	1	1
    1	1	1	0	1	1
미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.

위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.

## 입력
첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다.

## 출력
첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.

## Thinking!!
1은 이동할 수 있는 칸, 0은 이동할 수 없는 칸

### 의사 코드
    함수 BFS(start):
        큐 Q를 만들고
        visited와 dist 배열 모두 초기화
        Q.enqueue(start)
        visited[start] = True
        dist[start] = 0  // 혹은 1부터 세고 싶으면 1로 세팅
    
        while Q가 비어있지 않다면:
            현재 = Q.dequeue()
    
            // (그래프일 수도 있고, 2차원 그리드일 수도 있고)
            for 모든 인접 노드 next of 현재:
                if not visited[next]:
                    Q.enqueue(next)
                    visited[next] = True
                    dist[next] = dist[현재] + 1
    
        // 만약 특정 목적지 dest가 정해져 있다면,
        // “dest를 꺼낼 때” 바로 리턴해도 된다
        // (출발점→dest의 거리가 곧 최단 거리이기 때문)