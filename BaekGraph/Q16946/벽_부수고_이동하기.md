# Gold 2

## 문제
N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 한 칸에서 다른 칸으로 이동하려면, 두 칸이 인접해야 한다. 두 칸이 변을 공유할 때, 인접하다고 한다.

각각의 벽에 대해서 다음을 구해보려고 한다.

벽을 부수고 이동할 수 있는 곳으로 변경한다.
그 위치에서 이동할 수 있는 칸의 개수를 세어본다.
한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.

## 입력
첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다.

## 출력
맵의 형태로 정답을 출력한다. 원래 빈 칸인 곳은 0을 출력하고, 벽인 곳은 이동할 수 있는 칸의 개수를 10으로 나눈 나머지를 출력한다.

## Thinking!!


### 1차

    import sys
    from collections import deque
    
    input = sys.stdin.readline
    
    N, M = map(int, input().split())
    
    maps = [list(map(int, input().strip())) for _ in range(N)]
    g_id = [[0 for _ in range(M)] for _ in range(N)]
    
    for i in range(N):
        for j in range(M):
            if maps[i][j] == 1:
                g_id[i][j] = -1
    
    
    g_size = [0]
    group_id = 0
    
    d = [(1, 0), (0, 1), (-1, 0), (0, -1)]
    
    def bfs(si, sj, group_id):
        q = deque()
        q.append((si, sj))
        g_id[si][sj] = group_id
        cnt = 1
    
        while q:
            i, j = q.popleft()
            for di, dj in d:
                ni, nj = i + di, j + dj
                if 0 <= ni < N and 0 <= nj < M:
                    if maps[ni][nj] == 0 and g_id[ni][nj] == 0:
                        g_id[ni][nj] = group_id
                        q.append((ni, nj))
                        cnt += 1
    
        return cnt
    
    for i in range(N):
        for j in range(M):
            if maps[i][j] == 0 and g_id[i][j] == 0:
                group_id += 1
                size = bfs(i, j, group_id)
                g_size.append(size)
    
    for i in range(N):
        for j in range(M):
            size = 0
            if g_id[i][j] == -1:
                for di, dj in d:
                    ni, nj = i + di, j + dj
                    if 0 <= ni < N and 0 <= nj < M:
                        size += g_size[g_id[ni][nj]]
    
            print(size, end='')
        print()

수정해야할 것
1. 벽 칸 계산기 1부터 계산
2. 이웃 그룹은 g_id가 0보다 큰 경우에만 합산(벽은 -1로 정의해놨기 때문에)
3. seen을 사용해서 중복그룹을 합산하는것을 방지
4. 출력은 한줄에 join으로 처리