## Silver 1

## 문제
체스판 위에 한 나이트가 놓여져 있다. 나이트가 한 번에 이동할 수 있는 칸은 아래 그림에 나와있다. 나이트가 이동하려고 하는 칸이 주어진다. 나이트는 몇 번 움직이면 이 칸으로 이동할 수 있을까?

![img.png](img.png)

## 입력
입력의 첫째 줄에는 테스트 케이스의 개수가 주어진다.

각 테스트 케이스는 세 줄로 이루어져 있다. 첫째 줄에는 체스판의 한 변의 길이 l(4 ≤ l ≤ 300)이 주어진다. 체스판의 크기는 l × l이다. 체스판의 각 칸은 두 수의 쌍 {0, ..., l-1} × {0, ..., l-1}로 나타낼 수 있다. 둘째 줄과 셋째 줄에는 나이트가 현재 있는 칸, 나이트가 이동하려고 하는 칸이 주어진다.

## 출력
각 테스트 케이스마다 나이트가 최소 몇 번만에 이동할 수 있는지 출력한다.

## Thinking!!
오랜만에 실버문제 풀어봐야쥥~

    moves = [[1, 2], [2, 1], [-1, 2], [-2, 1], [-1, -2], [-2, -1], [1, -2], [2, -1]]
    
    def ste(path, dept, length):
        # 움직인 좌표의 값이 현재 시행횟수보다 크면 돌아감.
        if chess[path[0]][path[1]] >= dept:
            return
    
        # 움직인 좌표에, 현재 시행횟수 대입
        chess[path[0]][path[1]] = dept
    
        # 나이트의 움직임 8방향이 좌표값을 넘어가지 않게.
        for move in moves:
            if 0 <= path[0] + move[0] < length and 0 <= path[1] + move[1] < length:
                next_move = (path[0] + move[0], path[1] + move[1])
                ste(next_move, dept + 1, l)
    
    for i in range(T):
        l = int(input())
        chess = [[0]*l for _ in range(l)]
        start = list(map(int, input().split()))
        end = list(map(int, input().split()))
    
        ste(start, 0, l)
    
        print(chess[end[0]][end[1]])

흐름은 대충 이런 느낌인데, 이걸 dfs로 수정해보자.